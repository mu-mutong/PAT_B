/*
1025. 反转链表 (25)

给定一个常数K以及一个单链表L，
请编写程序将L中每K个结点反转。
例如：给定L为1→2→3→4→5→6，K为3，
则输出应该为3→2→1→6→5→4；
如果K为4，则输出应该为4→3→2→1→5→6，
即最后不到K个元素不反转。
输入格式： 
每个输入包含1个测试用例。
每个测试用例第1行给出第1个结点的地址、
结点总个数正整数N(<= 105)、以及正整数K(<=N)，
即要求反转的子链结点的个数。结点的地址是5位非负整数，
NULL地址用-1表示。
接下来有N行，每行格式为：
Address Data Next
其中Address是结点地址，Data是该结点保存的整数数据，
Next是下一结点的地址。
输出格式： 
对每个测试用例，顺序输出反转后的链表，
其上每个结点占一行，格式与输入相同。
输入样例：
00100 6 3
00000 4 -1
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218

输出样例：
00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1



*/
#include<stdio.h>
#include<string.h>
void reser(int a[],int begin,int end){
	int i=begin,j=end,bal=(begin+end)/2;
	for(i,j;i<=bal;i++,j--){
		int t=a[i];
		a[i]=a[j];
		a[j]=t;
	}
}
int main(){
	int i=1,num=0,add=0,first=0,n=0,key=0;
	int a[100003],b[100003],c[100003];
	scanf("%d %d %d",&first,&n,&key);
	for(i=0;i<n;i++){
		int t=0;
		scanf("%d",&t);
		scanf("%d %d",&a[t],&b[t]);
	}
	add=first;
	while(add!=-1){
		c[num++]=add;
		add=b[add];
	
	}
	for(i=0;i<num-num%key;i+=key){
		reser(c,i,i+key-1);
	}
	for(i=0;i<num-1;i++){
		printf("%05d %d %05d\n",c[i],a[c[i]],c[i+1]);
	}
	printf("%05d %d -1\n",c[i],a[c[i]]);
	return 0;
}
