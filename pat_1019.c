/*1019. 数字黑洞 (20)
时间限制 
100 ms
内存限制 
65536 kB
代码长度限制 
8000 B
判题程序 
Standard 
作者 
CHEN, Yue
给定任一个各位数字不完全相同的4位正整数，
如果我们先把4个数字按非递增排序，再按非递减排序，
然后用第1个数字减第2个数字，将得到一个新的数字。
一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，
这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
现给定任意4位正整数，请编写程序演示到达黑洞的过程。
输入格式： 
输入给出一个(0, 10000)区间内的正整数N。 
输出格式： 
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；
否则将计算的每一步在一行内输出，直到6174作为差出现，
输出格式见样例。注意每个数字按4位数格式输出。 
输入样例1：
6767
输出样例1：
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
输入样例2：
2222
输出样例2：
2222 - 2222 = 0000*/
#include<stdio.h>
void sort_n(int *max,int *min,int a[],int n){
	int i=0,j=0;
	for(i=0;i<n;i++){
		for(j=i+1;j<n;j++){
			if(a[i]>a[j]){
				int t;
				t=a[i];
				a[i]=a[j];
				a[j]=t;
			}
		}
	}
	for(i=0;i<n;i++){
		if(a[i]!=0){
			(*min)=(*min)*10+a[i];
		}
	}
	for(j=n-1;j>=0;j--){
		(*max)=(*max)*10+a[j];
	}
}
int main(){
	int n,m=0;
	int a[4];
	int i=0,max=0,min=0;
	char b[5];
	scanf("%d",&n);
    while(1){
    	while(i!=4){
    		a[i++]=n%10;
    		n=n/10;
    	}
    	sort_n(&max,&min,a,i);
    	
    	n=max-min;
    	m=n;
    	
    	b[4]='\0';
    	i=3;
    	while(i>=0){
    		b[i]=max%10+'0';
    		max=max/10;
    		i--;
    	}
    	printf("%s - ",b);
    	
    	i=3;
    	while(i>=0){
    		b[i]=min%10+'0';
    		min=min/10;
    		i--;
    	}
    	printf("%s = ",b);
    	
    	i=3;
    	while(i>=0){
    		b[i]=m%10+'0';
    		m=m/10;
    		i--;
    	}
    	printf("%s\n",b);
    	if(n==0||n==6174){
    		break;
    	}
    	max=0;
    	min=0;
    	i=0;
    }
	return 0;
}
